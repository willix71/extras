package w.dao.populator;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import w.dao.DaoHelper;

/**
 * Yet another 'framework' to easily insert data into a database...
 * <P>
 * This one tries to keep the name of the column and the value inserted as close to each other as possible.
 *
 * It also generates the insert statement automatically from the inserted fields so you specify the name of the column
 * once and only once!
 *
 * @see TablePopulatorTest for a sample usage
 *
 * @author wkeyser
 *
 */
public class TablePopulator {

	private static final Logger LOGGER = LoggerFactory.getLogger(TablePopulator.class);

	/**
	 * A pre-insert-processor. Can be used to track the progress of the populating process.
	 *
	 * @author wkeyser
	 *
	 */
	public static interface PreProcessor {
		/**
		 * @return if null, the populating process is halted else the current row is inserted
		 */
		RowPopulator prePropress(int index, RowPopulator current);
	}

	/**
	 * @author wkeyser
	 *
	 */
	public class RowPopulator {
		private Map<String, Object> fieldsValue = new HashMap<String, Object>();

		public void setBoolean(String name, Boolean value) {
			this.fieldsValue.put(name, value);
			setFieldType(name, Types.NUMERIC);
		}

		public void setBoolean(String name, Boolean value, boolean defaultValue) {
			this.fieldsValue.put(name, value == null ? defaultValue : value);
			setFieldType(name, Types.NUMERIC);
		}

		public void setLong(String name, Long value) {
			this.fieldsValue.put(name, value);
			setFieldType(name, Types.NUMERIC);
		}

		public void setDouble(String name, Double value) {
			this.fieldsValue.put(name, value);
			setFieldType(name, Types.DOUBLE);
		}

		public void setDate(String name, Date value) {
			this.fieldsValue.put(name, value == null ? null : new java.sql.Date(value.getTime()));
			setFieldType(name, Types.DATE);
		}

		public void setString(String name, String value) {
			this.fieldsValue.put(name, value);
			setFieldType(name, Types.VARCHAR);
		}

		public void setString(String name, String value, int maxvalue) {
			if (value == null || value.length() <= maxvalue) {
				setString(name, value);
			} else {
				setString(name, value.substring(0, maxvalue));
			}
		}

		public <T extends Enum<?>> void setEnum(String name, T value) {
			setString(name, value == null ? null : value.name());
		}

		public <T extends Enum<?>> void setEnum(String name, T value, int maxvalue) {
			setString(name, value == null ? null : value.name(), maxvalue);
		}

		public void populate(PreparedStatement preparedStatement) throws SQLException {
			int index = 1;
			for (Map.Entry<String, Integer> fieldTypeEntry : TablePopulator.this.fieldsType.entrySet()) {
				Object value = this.fieldsValue.get(fieldTypeEntry.getKey());
				if (value == null) {
					preparedStatement.setNull(index++, fieldTypeEntry.getValue());
				} else {
					preparedStatement.setObject(index++, value, fieldTypeEntry.getValue());
				}
			}
		}
	}

	private final String tableName;

	private SortedMap<String, Integer> fieldsType = new TreeMap<String, Integer>();

	private SortedMap<String, String> sqlFields = null;

	private List<RowPopulator> rowPopulators = new ArrayList<RowPopulator>();


	public TablePopulator(String tableName) {
		super();
		this.tableName = tableName;
	}

	private void setFieldType(String name, int type) {
		Integer currentType = this.fieldsType.put(name, type);
		if (currentType != null && currentType.intValue() != type) {
			// we have a problem
			String msg = String.format("Field's type named %s is being overriden; old value %d, new value %d", name, currentType, type);
			throw new IllegalArgumentException(msg);
		}
	}

	/**
	 * Adds a 'SQL' field.
	 *
	 * An sql field is a field which is generated by the sql statment itself (example sequence.nexval or a constant)
	 */
	public TablePopulator addSqlField(String name, String sql) {
		if (this.sqlFields == null) {
			this.sqlFields = new TreeMap<String, String>();
		}
		this.sqlFields.put(name, sql);
		return this;
	}

	public RowPopulator newRowPopulator(Object... dbgContext) {
		RowPopulator p = new RowPopulator();
		this.rowPopulators.add(p);
		return p;
	}

	public int size() {
		return this.rowPopulators.size();
	}

	public void populate(Connection connection) throws SQLException {
		populate(connection, new PreProcessor() {
			@Override
			public RowPopulator prePropress(int index, RowPopulator current) {
				LOGGER.debug("Inserting row {}, values {}", index, current.fieldsValue);
				return current;
			}
		});
	}

	public void populate(Connection connection, PreProcessor preProcessor) throws SQLException {
		if (!this.rowPopulators.isEmpty()) {

			String insertQuery = getInsertSql();

			LOGGER.debug("Executing {}", insertQuery);

			PreparedStatement preparedStatement = null;
			RowPopulator current = null;
			int i = 0;
			try {
				preparedStatement = connection.prepareStatement(insertQuery);

				// loop over rows
				for (RowPopulator p : this.rowPopulators) {
					current = preProcessor.prePropress(++i, p);

					if (current == null) {
						return; // cancel
					}

					current.populate(preparedStatement);

					preparedStatement.addBatch();
				}

				//
				// Execute batch
				//
				preparedStatement.executeBatch();

			} catch (SQLException e) {
				String errorMessage = "Could not export to table " + this.tableName + ", row " + i + ", values " + current.fieldsValue;
				LOGGER.error(errorMessage, e);

				throw new SQLException(errorMessage, errorMessage);
			} finally {
				DaoHelper.close(preparedStatement);
			}
		}
	}

	/**
	 * @return the SQL statement that will be used to populate the table
	 */
	public String getInsertSql() {
		return getInsertSql(this.tableName, this.fieldsType.keySet(), this.sqlFields);
	}

	public static String getInsertSql(String tableName, Collection<String> fields, Map<String, String> sqlFields) {
		StringBuilder sql = new StringBuilder("INSERT INTO ").append(tableName);
		
		Object linker = DaoHelper.criteriaLinker(" (", ",");
		for(String field: fields) {
			sql.append(linker).append(field);
		}

		if (sqlFields != null && !sqlFields.isEmpty()) {
			for(Map.Entry<String, String> entry: sqlFields.entrySet()) {
				sql.append(",").append(entry.getKey());
			}
		}

		sql.append(") VALUES (?");
		for (int i = 1; i < fields.size(); i++) {
			sql.append(",?");
		}

		if (sqlFields != null && !sqlFields.isEmpty()) {
			for(Map.Entry<String, String> entry: sqlFields.entrySet()) {
				sql.append(",").append(entry.getValue());
			}
		}

		sql.append(")");
		return sql.toString();
	}
}
